% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/qq_fit.R
\name{qq_fit}
\alias{qq_fit}
\title{Fit a Quantile on Quantiles Regression Model}
\usage{
qq_fit(
  formula,
  data,
  group,
  taus = seq(0.1, 0.9, by = 0.1),
  n_small = NULL,
  bootstrap = TRUE,
  nboot = 1000,
  parallel = TRUE,
  parallel_first = TRUE,
  ncores = NULL,
  weights = NULL
)
}
\arguments{
\item{formula}{A formula specifying the model, e.g., \code{y ~ x1 + x2}.}

\item{data}{A data frame containing the variables in the formula.}

\item{group}{A character string naming the grouping variable in \code{data}.}

\item{taus}{Numeric vector of quantile levels, default \code{seq(0.1, 0.9, 0.1)}.}

\item{n_small}{Numeric, minimum group size (default NULL). Groups with fewer
than \code{n_small} observations will be dropped with a message. If any group
has fewer observations than the number of covariates, the function will stop
with an error.}

\item{bootstrap}{Logical, whether to compute bootstrap standard errors (default TRUE).}

\item{nboot}{Number of bootstrap replications (default 1000).}

\item{parallel}{Logical, whether to parallelize computation (default TRUE).}

\item{parallel_first}{Logical, whether to parallelize the first stage across
groups (default TRUE).}

\item{ncores}{Number of cores to use. If NULL (default), uses 80\% of available cores.}

\item{weights}{Optional observation weights.}
}
\value{
An object of class \code{"qqfit"}, a list containing:
\item{coef}{Array of coefficients (k x n_tau x n_tau)}
\item{se}{Array of bootstrap standard errors (k x n_tau x n_tau), NULL if bootstrap = FALSE}
\item{coef_boot}{Array of bootstrap coefficient draws (k x n_tau x n_tau x nboot), NULL if bootstrap = FALSE}
\item{fitted}{Array of second-stage fitted values (n x n_tau x n_tau)}
\item{fitted_first}{Matrix of first-stage fitted values (n x n_tau)}
\item{rank}{Matrix of within-group ranks (n x n_tau)}
\item{residuals}{Array of second-stage residuals (n x n_tau x n_tau)}
\item{call}{The matched call}
\item{formula}{The model formula}
\item{taus}{The quantile grid}
\item{nobs}{Number of observations}
\item{ngroups}{Number of groups}
\item{var_types}{List of variable classifications}
\item{data}{The original data (sorted by group)}
\item{collapsed}{Logical, whether data was collapsed to group level}
}
\description{
Estimates a two-dimensional quantile surface capturing heterogeneity
both within and between groups using the two-step quantile regression
estimator from Pons (2026).
}
\details{
The model estimates:
\deqn{Q(v, Q(u, y_{ij} | x_{1,ij}, x_{2,j}) | x_{1,ij}, x_{2,j}) = x_1'\beta(u,v) + x_2'\gamma(u,v) + \alpha(u,v)}

where:
\itemize{
\item \eqn{u} is the within-group quantile index
\item \eqn{v} is the between-group quantile index
\item \eqn{x_1} are covariates that vary within groups
\item \eqn{x_2} are covariates that vary only between groups
}

Variables are automatically classified as:
\itemize{
\item \strong{within}: varies within ALL groups (used in first stage)
\item \strong{between}: constant within ALL groups (second stage only)
\item \strong{mixed}: varies within SOME groups (included appropriately per group)
}

If no within-group varying variables exist, the first stage computes
sample quantiles within each group, and the data is collapsed to the
group level with weights equal to group sizes.
}
\examples{
\donttest{
# Simulated data with heterogeneous effects
set.seed(123)
n_groups <- 50
n_per_group <- 50
n <- n_groups * n_per_group

# Covariates
x1 <- 1 + rnorm(n) + rep(runif(n_groups), each = n_per_group)
x2 <- rep(rnorm(n_groups), each = n_per_group)

# Shocks: eta (group-level), nu (individual-level)
eta <- rep(rnorm(n_groups), each = n_per_group)
nu <- rnorm(n)

# DGP: y = 1 + x1 + x2 + eta*(1 - 0.1*x1 - 0.1*x2) + nu*(1 + 0.1*x1 + 0.1*x2)
y <- 1 + x1 + x2 + eta * (1 - 0.1*x1 - 0.1*x2) + nu * (1 + 0.1*x1 + 0.1*x2)

data <- data.frame(
  group = rep(1:n_groups, each = n_per_group),
  x1 = x1,
  x2 = x2,
  y = y
)

# Fit model
fit <- qq_fit(y ~ x1 + x2, data = data, group = "group",
              taus = seq(0.1, 0.9, 0.1), nboot = 200)

# View results
summary(fit)
plot(fit, which = "x1", type = "surface")
plot(fit, which = "x1", type = "slice_u")
plot(fit, which = "x1", type = "slice_u", taus_slice = c(0.2, 0.8))

# Intercept-only model (no covariates)
fit_intercept <- qq_fit(y ~ 1, data = data, group = "group",
                        taus = seq(0.1, 0.9, 0.1), nboot = 200)

summary(fit_intercept)
plot(fit_intercept, which = "(Intercept)", type = "surface")
plot(fit_intercept, which = "(Intercept)", type = "slice_u")
}

}
